package com.sdq.libs.base.architecture

/**
 *
 * @PackageName com.sdq.libs.base.
 * @date 2022/8/9 9:57
 * @author songdongqi
 */

/**
 * AOP与插件化应该是一种抽象的概念或者叫做思想，而实现这种思想，需要有具体的方式，动态代理正好是实现这种思想的
 * 一种极好选择，然后在实现过程中，动态代理又需要利用一种叫做Hook的机制。
 */

/**
 * 动态代理：代理设计模式的一种实现，即代理类在程序运行时创建的代理方式被称为动态代理。
 *
 * 动态代理三种实现方法：
 * 1.JDK的动态代理：就是在程序运行的过程中，根据被代理的接口来动态生成代理类的class文 件，并加载运行的过程。
 * 2.cglib动态代理：cglib封装了asm,可以在运行期动态生成新的class，以此来实现动态代理。
 * 3.Javassist：Javassist是一个开源的分析、编辑和创建Java字节码的类库。
 */

/**
 * Hook是一种程序的运行机制，这种机制也能用动态代理来实现。
 * Hook：又叫钩子，通常是指对一些方法进行拦截（事件、信号、调用），具体一点来说就是程序运行中，创建代理对象，
 * 然后把原始对象替换为代理对象。
 *
 * 1.Hook是不是只能采用动态代理实现？
 * Hook主要是程序行的过程中使用代理对象来替换被Hook的对象，动态代理也是在运行中，但强调的代理类的创建，既然代
 * 理类能被创建，那代理对象肯定也能被创建，所以Hook肯定能采用动态代理来实现，但是否是唯一方式，就需要考查是否
 * 能不通过动态代理在程序运行时创建代理对象。显然是可以的，比如采用静态代理，即代理类在程序编译之前就提前写好，
 * 完全能达到Hook的目的，只是没有动态代理灵活而已。
 * 所以Hook不只是能采用动态代理实现。

 * 2.Hook是不是只能采用代理方式实现？
 * 上面说了Hook还可以采用静态代理来实现，那么还没有其它方式实现Hook，完全不使用动态或静态代理？
 * 个人认为是不可能的，因为我们可以把Hook理解为钩子，这个钩子其实就是一个代理，虽然实现时可能会不完全符合代理
 * 模式的定义（比如可能并没有在代理对象里访问原对象），但是从本质上来说，这还是一种代理方式。
 * 所以说Hook只能采用代理方式实现，更准确来说，Hook就是一种代理机制。
 *
 * Hook的步骤：
 * 1.寻找适合Hook点，它应该是一个成员变量，并且应该在我们需要注入的方法中调用过它的方法或者使用了它的的值。
 * 2.创建继承自Hook点的对象的子类，根据需求修改其相应的方法。
 * 3.使用反射将我们自己创建的对象替换对象实例中的对象，达到偷梁换柱的目的。
 */
class Hook

/**
 * AOP：
 * 本质是动态代理
 * 面向切面编程，是一种编程思想，也就是说面向某个功能模块编程，在代码层面上将该模块与其它有交叉的模块进行隔离。
 *
 * 1.AOP是不是只能采用动态代理实现？
 * AOP是一种可以通过预编译和运行期动态代理实现而不用修改源代码的情况下给程序动态添加功能的一种技术。
 * 本质上就是动态代理，只不过有各种实现技术而已。
 * 所以AOP只能采用动态代理实现。
 *
 * 2.AOP是不是必须用到Hook机制？
 * AOP实现时有三种方式：生成子类字节码、生成代理类字节码、直接修改原类的字节码。
 * Hook机制关注点在于对象的替换，如果我们直接修改了原类的字节码加入切面逻辑，是不存在Hook的，因为连Class都被
 * 修改了。如果生成了代理类的字节码，再由字节码生成代理类的对象，然后用代理类的对象来替换原对象，这是一个标准
 * 的Hook过程，肯定使用了Hook机制。
 * 所以AOP实现采用Hook机制只是其中一种方式，不是必须的方式。
 *
 * 实现方式：
 * 1.运行时AOP:运行时动态生成子类字节码(Cglib)或代理类字节码(JDK动态代理)或直接修改字节码(Javassist、ASM、AspectJ)
 * 2.编译时AOP:编译时，修改字节码(ASM、AspectJ)或生成代理类(APT)
 * 类加载器：在目标类呗装载到jvm时，通过一个特殊的类加载器，对目标类的字节码重新增强
 */
class AOP

/**
 * 插件化技术：
 * 也叫动态加载技术，将整个app拆分成很多模块，这些模块包括一个宿主和多个插件，每个模块都是一个apk，插件模块无需安装，由宿主模块动态加载。
 *
 * 插件化技术是不是只能采用动态代理来实现？
 * 目前有很多插件化框架，基本上都用到了动态代理，比如DroidPlugin，但是否只能用动态代理来实现，回答是否定的。
 * 插件化即宿主APK动态加载插件APK，而插件APK是不需要安装的，所以插件化主要解决两个问题：代码加载与资源加载。
 * 其中的资源加载就不需要使用动态代理。
 *
 * 代码加载是否一定要使用动态代理？回答也是否定的。
 * 因为我们只要能实现动态加载代码就能达到目的，如果假设Android的Activity不需要在Manifest中注册，那么完全
 * 可以直接采用反射加载Activity类，但是实际上Android有一套组件访问机制，正因为这套访问机制会限制对非安装APK
 * 的加载，所以很多框架才需要使用动态代理的Hook机制来绕过系统的访问机制。而且除了动态代理，静态代理方式也能达
 * 到Hook的目的。
 *
 * 总结一下就是说，插件化与动态代理没有直接联系，只要我们能想办法解决好代码加载与资源加载的问题，就能实现插件
 * 化技术，动态代理的Hook机制只是提供了一种解决问题的思路，而且这种思路使问题的解决比较简单。
 *
 * 使用动态加载，就是使用类加载器加载相应的apk、dex、jar（必须含有dex文件），再通过反射获得该apk、dex、jar内
 * 部的资源（class、图片、color等等）进而供宿主app使用。
 */
class Plugin